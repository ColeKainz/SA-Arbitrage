"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
const util_1 = require("util");
/**
 * Actively handles the heartbeat ping/pong mechanism respecting
 * the specified parameters.
 */
class HeartbeatHandler {
    /**
     * Default constructor.
     *
     * @param websocket    The web socket instance on which we want to
     *                     perform the checks and start the monitoring.
     * @param pingInterval The interval between which ping/pong messages
     *                     are exchanged between client and server
     *                     (defaults to 1 minute).
     * @param onDeath      Callback called on client/server connection end,
     *                     detected from missing heartbeat updates.
     */
    constructor(websocket, pingInterval, onDeath) {
        this.STATE_OPEN = 1;
        this.STATE_CLOSED = 3;
        this.websocket = websocket;
        this.pingInterval = pingInterval;
        this.onDeath = onDeath;
        this.alive = true;
    }
    /**
     * Does some basic checks about the web socket state and starts
     * the actual heartbeat monitoring.
     */
    handle() {
        this.websocket.on("pong", () => {
            this.alive = true;
        });
        if (this.websocket.readyState !== this.STATE_OPEN) {
            this.websocket.on("open", () => {
                this.handleHeartbeat();
            });
            return;
        }
        this.handleHeartbeat();
    }
    /**
     * Implements the business logic required for the heartbeat detection to work.
     * If the heartbeat stops respecting the previously-set timeout, the client/server
     * connection is considered dead and the eventually passed in callback is called.
     * The web socket is also closed with code 1008 (policy violation) and message
     * "Heartbeat stopped".
     */
    handleHeartbeat() {
        let timer = setInterval(() => {
            if (this.websocket.readyState === this.STATE_CLOSED) {
                clearInterval(timer);
                return;
            }
            if (!this.alive) {
                if (!util_1.isNullOrUndefined(this.onDeath)) {
                    this.onDeath();
                }
                this.websocket.terminate();
                clearInterval(timer);
                return;
            }
            this.alive = false;
            this.websocket.ping();
        }, this.pingInterval);
    }
}
exports.HeartbeatHandler = HeartbeatHandler;
//# sourceMappingURL=HeartbeatHandler.js.map